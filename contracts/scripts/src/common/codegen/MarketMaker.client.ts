/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.9.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { TokenUnverified, InstantiateMsg, ExecuteMsg, Uint128, Decimal, BidType, Addr, BiddedCollateralItem, TokenItem, QueryMsg, MigrateMsg, ArrayOfCollectionInfoForAddr, CollectionInfoForAddr, ArrayOfCollateralListResponseItem, CollateralListResponseItem, CollectionOwnerForAddr, ArrayOfCollectionOwnerForAddr, Token, Config, LiquidityInfo, ArrayOfLiquidityInfo, OffersResponse, ArrayOfOffersResponse } from "./MarketMaker.types";
export interface MarketMakerReadOnlyInterface {
  contractAddress: string;
  queryConfig: () => Promise<Config>;
  queryOfferPricesList: ({
    amount,
    startAfter
  }: {
    amount: number;
    startAfter?: string;
  }) => Promise<ArrayOfOffersResponse>;
  queryOfferPrices: ({
    collection
  }: {
    collection: string;
  }) => Promise<OffersResponse>;
  queryCollectionOwnerList: ({
    amount,
    startAfter
  }: {
    amount: number;
    startAfter?: string;
  }) => Promise<ArrayOfCollectionOwnerForAddr>;
  queryCollectionOwner: ({
    collection
  }: {
    collection: string;
  }) => Promise<CollectionOwnerForAddr>;
  queryLiquidityList: ({
    amount,
    startAfter
  }: {
    amount: number;
    startAfter?: string;
  }) => Promise<ArrayOfLiquidityInfo>;
  queryLiquidity: ({
    collection
  }: {
    collection: string;
  }) => Promise<LiquidityInfo>;
  queryCollateralList: ({
    amount,
    startAfter
  }: {
    amount: number;
    startAfter?: string;
  }) => Promise<ArrayOfCollateralListResponseItem>;
  queryCollateral: ({
    collectionOwner
  }: {
    collectionOwner: string;
  }) => Promise<ArrayOfCollectionInfoForAddr>;
}
export class MarketMakerQueryClient implements MarketMakerReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;
  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.queryConfig = this.queryConfig.bind(this);
    this.queryOfferPricesList = this.queryOfferPricesList.bind(this);
    this.queryOfferPrices = this.queryOfferPrices.bind(this);
    this.queryCollectionOwnerList = this.queryCollectionOwnerList.bind(this);
    this.queryCollectionOwner = this.queryCollectionOwner.bind(this);
    this.queryLiquidityList = this.queryLiquidityList.bind(this);
    this.queryLiquidity = this.queryLiquidity.bind(this);
    this.queryCollateralList = this.queryCollateralList.bind(this);
    this.queryCollateral = this.queryCollateral.bind(this);
  }
  queryConfig = async (): Promise<Config> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_config: {}
    });
  };
  queryOfferPricesList = async ({
    amount,
    startAfter
  }: {
    amount: number;
    startAfter?: string;
  }): Promise<ArrayOfOffersResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_offer_prices_list: {
        amount,
        start_after: startAfter
      }
    });
  };
  queryOfferPrices = async ({
    collection
  }: {
    collection: string;
  }): Promise<OffersResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_offer_prices: {
        collection
      }
    });
  };
  queryCollectionOwnerList = async ({
    amount,
    startAfter
  }: {
    amount: number;
    startAfter?: string;
  }): Promise<ArrayOfCollectionOwnerForAddr> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_collection_owner_list: {
        amount,
        start_after: startAfter
      }
    });
  };
  queryCollectionOwner = async ({
    collection
  }: {
    collection: string;
  }): Promise<CollectionOwnerForAddr> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_collection_owner: {
        collection
      }
    });
  };
  queryLiquidityList = async ({
    amount,
    startAfter
  }: {
    amount: number;
    startAfter?: string;
  }): Promise<ArrayOfLiquidityInfo> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_liquidity_list: {
        amount,
        start_after: startAfter
      }
    });
  };
  queryLiquidity = async ({
    collection
  }: {
    collection: string;
  }): Promise<LiquidityInfo> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_liquidity: {
        collection
      }
    });
  };
  queryCollateralList = async ({
    amount,
    startAfter
  }: {
    amount: number;
    startAfter?: string;
  }): Promise<ArrayOfCollateralListResponseItem> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_collateral_list: {
        amount,
        start_after: startAfter
      }
    });
  };
  queryCollateral = async ({
    collectionOwner
  }: {
    collectionOwner: string;
  }): Promise<ArrayOfCollectionInfoForAddr> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_collateral: {
        collection_owner: collectionOwner
      }
    });
  };
}
export interface MarketMakerInterface extends MarketMakerReadOnlyInterface {
  contractAddress: string;
  sender: string;
  acceptAdminRole: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateConfig: ({
    admin,
    controller,
    lendingPlatform,
    oracle,
    token,
    worker
  }: {
    admin?: string;
    controller?: string[];
    lendingPlatform?: string;
    oracle?: string;
    token?: TokenUnverified;
    worker?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  removeOffers: ({
    collection,
    recipient
  }: {
    collection: string;
    recipient?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  pause: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  unpause: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setCollection: ({
    collection,
    owner
  }: {
    collection: string;
    owner: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  removeCollections: ({
    collectionList
  }: {
    collectionList: string[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  depositLiquidity: ({
    collection
  }: {
    collection: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  withdrawUndistributedLiquidity: ({
    collection
  }: {
    collection: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  withdrawCollateral: ({
    collection
  }: {
    collection: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateOffers: ({
    collection,
    fromToPriceList
  }: {
    collection: string;
    fromToPriceList: Uint128[][];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  acceptOffers: ({
    biddedCollateralItemList
  }: {
    biddedCollateralItemList: BiddedCollateralItem[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class MarketMakerClient extends MarketMakerQueryClient implements MarketMakerInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;
  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.acceptAdminRole = this.acceptAdminRole.bind(this);
    this.updateConfig = this.updateConfig.bind(this);
    this.removeOffers = this.removeOffers.bind(this);
    this.pause = this.pause.bind(this);
    this.unpause = this.unpause.bind(this);
    this.setCollection = this.setCollection.bind(this);
    this.removeCollections = this.removeCollections.bind(this);
    this.depositLiquidity = this.depositLiquidity.bind(this);
    this.withdrawUndistributedLiquidity = this.withdrawUndistributedLiquidity.bind(this);
    this.withdrawCollateral = this.withdrawCollateral.bind(this);
    this.updateOffers = this.updateOffers.bind(this);
    this.acceptOffers = this.acceptOffers.bind(this);
  }
  acceptAdminRole = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      accept_admin_role: {}
    }, fee, memo, _funds);
  };
  updateConfig = async ({
    admin,
    controller,
    lendingPlatform,
    oracle,
    token,
    worker
  }: {
    admin?: string;
    controller?: string[];
    lendingPlatform?: string;
    oracle?: string;
    token?: TokenUnverified;
    worker?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_config: {
        admin,
        controller,
        lending_platform: lendingPlatform,
        oracle,
        token,
        worker
      }
    }, fee, memo, _funds);
  };
  removeOffers = async ({
    collection,
    recipient
  }: {
    collection: string;
    recipient?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_offers: {
        collection,
        recipient
      }
    }, fee, memo, _funds);
  };
  pause = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      pause: {}
    }, fee, memo, _funds);
  };
  unpause = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unpause: {}
    }, fee, memo, _funds);
  };
  setCollection = async ({
    collection,
    owner
  }: {
    collection: string;
    owner: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_collection: {
        collection,
        owner
      }
    }, fee, memo, _funds);
  };
  removeCollections = async ({
    collectionList
  }: {
    collectionList: string[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_collections: {
        collection_list: collectionList
      }
    }, fee, memo, _funds);
  };
  depositLiquidity = async ({
    collection
  }: {
    collection: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      deposit_liquidity: {
        collection
      }
    }, fee, memo, _funds);
  };
  withdrawUndistributedLiquidity = async ({
    collection
  }: {
    collection: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw_undistributed_liquidity: {
        collection
      }
    }, fee, memo, _funds);
  };
  withdrawCollateral = async ({
    collection
  }: {
    collection: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw_collateral: {
        collection
      }
    }, fee, memo, _funds);
  };
  updateOffers = async ({
    collection,
    fromToPriceList
  }: {
    collection: string;
    fromToPriceList: Uint128[][];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_offers: {
        collection,
        from_to_price_list: fromToPriceList
      }
    }, fee, memo, _funds);
  };
  acceptOffers = async ({
    biddedCollateralItemList
  }: {
    biddedCollateralItemList: BiddedCollateralItem[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      accept_offers: {
        bidded_collateral_item_list: biddedCollateralItemList
      }
    }, fee, memo, _funds);
  };
}