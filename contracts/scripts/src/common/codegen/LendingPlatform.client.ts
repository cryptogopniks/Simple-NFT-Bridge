/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.9.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { TokenUnverified, Decimal, Uint128, InstantiateMsg, CurrencyForTokenUnverified, ExecuteMsg, Binary, BidType, Addr, ProposalStatus, ProposalTypeForString, Cw20ReceiveMsg, CollectionInfoForString, LiquidationItem, BiddedCollateralItem, TokenItem, ProposalForStringAndTokenUnverified, FundsForTokenUnverified, CollectionForString, QueryMsg, MigrateMsg, AddressConfig, QueryAmountsResponse, Balances, RegularBalances, Vault, ReserveBalances, Borrower, ArrayOfQueryBorrowersResponseItem, QueryBorrowersResponseItem, ArrayOfCollateral, Collateral, ArrayOfQueryCollateralsResponseItem, QueryCollateralsResponseItem, CollectionForAddr, ArrayOfQueryCollectionsResponseItem, QueryCollectionsResponseItem, Token, CommonConfig, CurrencyForToken, ArrayOfLiquidationBid, LiquidationBid, ArrayOfQueryLiquidationBidsByCollectionAddressListResponseItem, QueryLiquidationBidsByCollectionAddressListResponseItem, ArrayOfQueryLiquidationBidsByLiquidatorAddressListResponseItem, QueryLiquidationBidsByLiquidatorAddressListResponseItem, Liquidator, ArrayOfQueryLiquidatorsResponseItem, QueryLiquidatorsResponseItem, ArrayOfTupleOfAddrAndNullable_Decimal, ArrayOfFundsForToken, FundsForToken, ProposalTypeForAddr, ArrayOfQueryProposalsResponseItem, QueryProposalsResponseItem, ProposalForAddrAndToken, RateConfig, Unbonder, ArrayOfQueryUnbondersResponseItem, QueryUnbondersResponseItem, QueryUserInfoResponse } from "./LendingPlatform.types";
export interface LendingPlatformReadOnlyInterface {
  contractAddress: string;
  queryAddressConfig: () => Promise<AddressConfig>;
  queryRateConfig: () => Promise<RateConfig>;
  queryCommonConfig: () => Promise<CommonConfig>;
  queryPlatformRevenue: () => Promise<ArrayOfFundsForToken>;
  queryBalances: () => Promise<Balances>;
  queryUnbonderList: ({
    amount,
    startAfter
  }: {
    amount: number;
    startAfter?: string;
  }) => Promise<ArrayOfQueryUnbondersResponseItem>;
  queryUnbonder: ({
    address
  }: {
    address: string;
  }) => Promise<Unbonder>;
  queryBorrowerList: ({
    amount,
    startAfter
  }: {
    amount: number;
    startAfter?: string;
  }) => Promise<ArrayOfQueryBorrowersResponseItem>;
  queryBorrower: ({
    address
  }: {
    address: string;
  }) => Promise<Borrower>;
  queryLiquidatorList: ({
    amount,
    startAfter
  }: {
    amount: number;
    startAfter?: string;
  }) => Promise<ArrayOfQueryLiquidatorsResponseItem>;
  queryLiquidator: ({
    address
  }: {
    address: string;
  }) => Promise<Liquidator>;
  queryCollateralList: ({
    amount,
    startAfter
  }: {
    amount: number;
    startAfter?: string;
  }) => Promise<ArrayOfQueryCollateralsResponseItem>;
  queryCollateral: ({
    collectionAddress
  }: {
    collectionAddress: string;
  }) => Promise<ArrayOfCollateral>;
  queryCollateralByOwner: ({
    owner
  }: {
    owner: string;
  }) => Promise<ArrayOfQueryCollateralsResponseItem>;
  queryLiquidationBidsByCollectionAddressList: ({
    amount,
    startAfter
  }: {
    amount: number;
    startAfter?: string;
  }) => Promise<ArrayOfQueryLiquidationBidsByCollectionAddressListResponseItem>;
  queryLiquidationBidsByCollectionAddress: ({
    address
  }: {
    address: string;
  }) => Promise<ArrayOfLiquidationBid>;
  queryLiquidationBidsByLiquidatorAddressList: ({
    amount,
    startAfter
  }: {
    amount: number;
    startAfter?: string;
  }) => Promise<ArrayOfQueryLiquidationBidsByLiquidatorAddressListResponseItem>;
  queryLiquidationBidsByLiquidatorAddress: ({
    address
  }: {
    address: string;
  }) => Promise<ArrayOfQueryLiquidationBidsByCollectionAddressListResponseItem>;
  queryProposals: ({
    amount,
    startAfter
  }: {
    amount: number;
    startAfter?: number;
  }) => Promise<ArrayOfQueryProposalsResponseItem>;
  queryCollectionList: ({
    amount,
    startAfter
  }: {
    amount: number;
    startAfter?: string;
  }) => Promise<ArrayOfQueryCollectionsResponseItem>;
  queryCollection: ({
    address
  }: {
    address: string;
  }) => Promise<CollectionForAddr>;
  queryBglCurrencyToMainCurrencyPrice: () => Promise<Decimal>;
  queryConditionalDepositApr: ({
    amountToDeposit,
    amountToWithdraw
  }: {
    amountToDeposit?: Uint128;
    amountToWithdraw?: Uint128;
  }) => Promise<Decimal>;
  queryLtvList: ({
    amount,
    startAfter
  }: {
    amount: number;
    startAfter?: string;
  }) => Promise<ArrayOfTupleOfAddrAndNullableDecimal>;
  queryConditionalLtv: ({
    amountToBorrow,
    amountToDeposit,
    amountToRepay,
    amountToWithdraw,
    borrower
  }: {
    amountToBorrow?: Uint128;
    amountToDeposit?: Uint128;
    amountToRepay?: Uint128;
    amountToWithdraw?: Uint128;
    borrower: string;
  }) => Promise<Decimal>;
  queryTotalAvailableToBorrowLiquidity: () => Promise<Uint128>;
  queryAvailableToBorrow: ({
    borrower,
    targetLtv
  }: {
    borrower: string;
    targetLtv?: Decimal;
  }) => Promise<Uint128>;
  queryAmounts: () => Promise<QueryAmountsResponse>;
  queryUserInfo: ({
    address
  }: {
    address: string;
  }) => Promise<QueryUserInfoResponse>;
}
export class LendingPlatformQueryClient implements LendingPlatformReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;
  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.queryAddressConfig = this.queryAddressConfig.bind(this);
    this.queryRateConfig = this.queryRateConfig.bind(this);
    this.queryCommonConfig = this.queryCommonConfig.bind(this);
    this.queryPlatformRevenue = this.queryPlatformRevenue.bind(this);
    this.queryBalances = this.queryBalances.bind(this);
    this.queryUnbonderList = this.queryUnbonderList.bind(this);
    this.queryUnbonder = this.queryUnbonder.bind(this);
    this.queryBorrowerList = this.queryBorrowerList.bind(this);
    this.queryBorrower = this.queryBorrower.bind(this);
    this.queryLiquidatorList = this.queryLiquidatorList.bind(this);
    this.queryLiquidator = this.queryLiquidator.bind(this);
    this.queryCollateralList = this.queryCollateralList.bind(this);
    this.queryCollateral = this.queryCollateral.bind(this);
    this.queryCollateralByOwner = this.queryCollateralByOwner.bind(this);
    this.queryLiquidationBidsByCollectionAddressList = this.queryLiquidationBidsByCollectionAddressList.bind(this);
    this.queryLiquidationBidsByCollectionAddress = this.queryLiquidationBidsByCollectionAddress.bind(this);
    this.queryLiquidationBidsByLiquidatorAddressList = this.queryLiquidationBidsByLiquidatorAddressList.bind(this);
    this.queryLiquidationBidsByLiquidatorAddress = this.queryLiquidationBidsByLiquidatorAddress.bind(this);
    this.queryProposals = this.queryProposals.bind(this);
    this.queryCollectionList = this.queryCollectionList.bind(this);
    this.queryCollection = this.queryCollection.bind(this);
    this.queryBglCurrencyToMainCurrencyPrice = this.queryBglCurrencyToMainCurrencyPrice.bind(this);
    this.queryConditionalDepositApr = this.queryConditionalDepositApr.bind(this);
    this.queryLtvList = this.queryLtvList.bind(this);
    this.queryConditionalLtv = this.queryConditionalLtv.bind(this);
    this.queryTotalAvailableToBorrowLiquidity = this.queryTotalAvailableToBorrowLiquidity.bind(this);
    this.queryAvailableToBorrow = this.queryAvailableToBorrow.bind(this);
    this.queryAmounts = this.queryAmounts.bind(this);
    this.queryUserInfo = this.queryUserInfo.bind(this);
  }
  queryAddressConfig = async (): Promise<AddressConfig> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_address_config: {}
    });
  };
  queryRateConfig = async (): Promise<RateConfig> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_rate_config: {}
    });
  };
  queryCommonConfig = async (): Promise<CommonConfig> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_common_config: {}
    });
  };
  queryPlatformRevenue = async (): Promise<ArrayOfFundsForToken> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_platform_revenue: {}
    });
  };
  queryBalances = async (): Promise<Balances> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_balances: {}
    });
  };
  queryUnbonderList = async ({
    amount,
    startAfter
  }: {
    amount: number;
    startAfter?: string;
  }): Promise<ArrayOfQueryUnbondersResponseItem> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_unbonder_list: {
        amount,
        start_after: startAfter
      }
    });
  };
  queryUnbonder = async ({
    address
  }: {
    address: string;
  }): Promise<Unbonder> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_unbonder: {
        address
      }
    });
  };
  queryBorrowerList = async ({
    amount,
    startAfter
  }: {
    amount: number;
    startAfter?: string;
  }): Promise<ArrayOfQueryBorrowersResponseItem> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_borrower_list: {
        amount,
        start_after: startAfter
      }
    });
  };
  queryBorrower = async ({
    address
  }: {
    address: string;
  }): Promise<Borrower> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_borrower: {
        address
      }
    });
  };
  queryLiquidatorList = async ({
    amount,
    startAfter
  }: {
    amount: number;
    startAfter?: string;
  }): Promise<ArrayOfQueryLiquidatorsResponseItem> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_liquidator_list: {
        amount,
        start_after: startAfter
      }
    });
  };
  queryLiquidator = async ({
    address
  }: {
    address: string;
  }): Promise<Liquidator> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_liquidator: {
        address
      }
    });
  };
  queryCollateralList = async ({
    amount,
    startAfter
  }: {
    amount: number;
    startAfter?: string;
  }): Promise<ArrayOfQueryCollateralsResponseItem> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_collateral_list: {
        amount,
        start_after: startAfter
      }
    });
  };
  queryCollateral = async ({
    collectionAddress
  }: {
    collectionAddress: string;
  }): Promise<ArrayOfCollateral> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_collateral: {
        collection_address: collectionAddress
      }
    });
  };
  queryCollateralByOwner = async ({
    owner
  }: {
    owner: string;
  }): Promise<ArrayOfQueryCollateralsResponseItem> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_collateral_by_owner: {
        owner
      }
    });
  };
  queryLiquidationBidsByCollectionAddressList = async ({
    amount,
    startAfter
  }: {
    amount: number;
    startAfter?: string;
  }): Promise<ArrayOfQueryLiquidationBidsByCollectionAddressListResponseItem> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_liquidation_bids_by_collection_address_list: {
        amount,
        start_after: startAfter
      }
    });
  };
  queryLiquidationBidsByCollectionAddress = async ({
    address
  }: {
    address: string;
  }): Promise<ArrayOfLiquidationBid> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_liquidation_bids_by_collection_address: {
        address
      }
    });
  };
  queryLiquidationBidsByLiquidatorAddressList = async ({
    amount,
    startAfter
  }: {
    amount: number;
    startAfter?: string;
  }): Promise<ArrayOfQueryLiquidationBidsByLiquidatorAddressListResponseItem> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_liquidation_bids_by_liquidator_address_list: {
        amount,
        start_after: startAfter
      }
    });
  };
  queryLiquidationBidsByLiquidatorAddress = async ({
    address
  }: {
    address: string;
  }): Promise<ArrayOfQueryLiquidationBidsByCollectionAddressListResponseItem> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_liquidation_bids_by_liquidator_address: {
        address
      }
    });
  };
  queryProposals = async ({
    amount,
    startAfter
  }: {
    amount: number;
    startAfter?: number;
  }): Promise<ArrayOfQueryProposalsResponseItem> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_proposals: {
        amount,
        start_after: startAfter
      }
    });
  };
  queryCollectionList = async ({
    amount,
    startAfter
  }: {
    amount: number;
    startAfter?: string;
  }): Promise<ArrayOfQueryCollectionsResponseItem> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_collection_list: {
        amount,
        start_after: startAfter
      }
    });
  };
  queryCollection = async ({
    address
  }: {
    address: string;
  }): Promise<CollectionForAddr> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_collection: {
        address
      }
    });
  };
  queryBglCurrencyToMainCurrencyPrice = async (): Promise<Decimal> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_bgl_currency_to_main_currency_price: {}
    });
  };
  queryConditionalDepositApr = async ({
    amountToDeposit,
    amountToWithdraw
  }: {
    amountToDeposit?: Uint128;
    amountToWithdraw?: Uint128;
  }): Promise<Decimal> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_conditional_deposit_apr: {
        amount_to_deposit: amountToDeposit,
        amount_to_withdraw: amountToWithdraw
      }
    });
  };
  queryLtvList = async ({
    amount,
    startAfter
  }: {
    amount: number;
    startAfter?: string;
  }): Promise<ArrayOfTupleOfAddrAndNullableDecimal> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_ltv_list: {
        amount,
        start_after: startAfter
      }
    });
  };
  queryConditionalLtv = async ({
    amountToBorrow,
    amountToDeposit,
    amountToRepay,
    amountToWithdraw,
    borrower
  }: {
    amountToBorrow?: Uint128;
    amountToDeposit?: Uint128;
    amountToRepay?: Uint128;
    amountToWithdraw?: Uint128;
    borrower: string;
  }): Promise<Decimal> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_conditional_ltv: {
        amount_to_borrow: amountToBorrow,
        amount_to_deposit: amountToDeposit,
        amount_to_repay: amountToRepay,
        amount_to_withdraw: amountToWithdraw,
        borrower
      }
    });
  };
  queryTotalAvailableToBorrowLiquidity = async (): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_total_available_to_borrow_liquidity: {}
    });
  };
  queryAvailableToBorrow = async ({
    borrower,
    targetLtv
  }: {
    borrower: string;
    targetLtv?: Decimal;
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_available_to_borrow: {
        borrower,
        target_ltv: targetLtv
      }
    });
  };
  queryAmounts = async (): Promise<QueryAmountsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_amounts: {}
    });
  };
  queryUserInfo = async ({
    address
  }: {
    address: string;
  }): Promise<QueryUserInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_user_info: {
        address
      }
    });
  };
}
export interface LendingPlatformInterface extends LendingPlatformReadOnlyInterface {
  contractAddress: string;
  sender: string;
  receive: ({
    amount,
    msg,
    sender
  }: {
    amount: Uint128;
    msg: Binary;
    sender: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  deposit: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  unbond: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  withdraw: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  withdrawCollateral: ({
    collections
  }: {
    collections: CollectionInfoForString[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  depositCollateral: ({
    collections
  }: {
    collections: CollectionInfoForString[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  borrow: ({
    amount
  }: {
    amount: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  repay: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  placeBid: ({
    collections,
    discount
  }: {
    collections: CollectionInfoForString[];
    discount: Decimal;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateBid: ({
    amount,
    collections,
    creationDate,
    discount
  }: {
    amount: Uint128;
    collections: CollectionInfoForString[];
    creationDate: number;
    discount: Decimal;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  removeBid: ({
    collectionAddresses,
    creationDate
  }: {
    collectionAddresses: string[];
    creationDate: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  liquidate: ({
    targets
  }: {
    targets: LiquidationItem[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  acceptAdminRole: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateAddressConfig: ({
    admin,
    marketMaker,
    minter,
    oracle,
    scheduler,
    worker
  }: {
    admin?: string;
    marketMaker?: string;
    minter?: string;
    oracle?: string;
    scheduler?: string;
    worker?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateRateConfig: ({
    bidMinRate,
    borrowApr,
    borrowFeeRate,
    discountMaxRate,
    discountMinRate,
    liquidationFeeRate
  }: {
    bidMinRate?: Decimal;
    borrowApr?: Decimal;
    borrowFeeRate?: Decimal;
    discountMaxRate?: Decimal;
    discountMinRate?: Decimal;
    liquidationFeeRate?: Decimal;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateCommonConfig: ({
    bglCurrency,
    borrowersReserveFractionRatio,
    collateralMinValue,
    mainCurrency,
    unbondingPeriod
  }: {
    bglCurrency?: CurrencyForTokenUnverified;
    borrowersReserveFractionRatio?: Decimal;
    collateralMinValue?: Uint128;
    mainCurrency?: CurrencyForTokenUnverified;
    unbondingPeriod?: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  depositReserveLiquidity: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  withdrawReserveLiquidity: ({
    amount
  }: {
    amount: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  reinforceBglToken: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  pause: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  unpause: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  distributeFunds: ({
    addressAndWeightList
  }: {
    addressAndWeightList: string[][];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  removeCollection: ({
    address
  }: {
    address: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  createProposal: ({
    proposal
  }: {
    proposal: ProposalForStringAndTokenUnverified;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  rejectProposal: ({
    id
  }: {
    id: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  acceptProposal: ({
    id
  }: {
    id: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class LendingPlatformClient extends LendingPlatformQueryClient implements LendingPlatformInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;
  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.receive = this.receive.bind(this);
    this.deposit = this.deposit.bind(this);
    this.unbond = this.unbond.bind(this);
    this.withdraw = this.withdraw.bind(this);
    this.withdrawCollateral = this.withdrawCollateral.bind(this);
    this.depositCollateral = this.depositCollateral.bind(this);
    this.borrow = this.borrow.bind(this);
    this.repay = this.repay.bind(this);
    this.placeBid = this.placeBid.bind(this);
    this.updateBid = this.updateBid.bind(this);
    this.removeBid = this.removeBid.bind(this);
    this.liquidate = this.liquidate.bind(this);
    this.acceptAdminRole = this.acceptAdminRole.bind(this);
    this.updateAddressConfig = this.updateAddressConfig.bind(this);
    this.updateRateConfig = this.updateRateConfig.bind(this);
    this.updateCommonConfig = this.updateCommonConfig.bind(this);
    this.depositReserveLiquidity = this.depositReserveLiquidity.bind(this);
    this.withdrawReserveLiquidity = this.withdrawReserveLiquidity.bind(this);
    this.reinforceBglToken = this.reinforceBglToken.bind(this);
    this.pause = this.pause.bind(this);
    this.unpause = this.unpause.bind(this);
    this.distributeFunds = this.distributeFunds.bind(this);
    this.removeCollection = this.removeCollection.bind(this);
    this.createProposal = this.createProposal.bind(this);
    this.rejectProposal = this.rejectProposal.bind(this);
    this.acceptProposal = this.acceptProposal.bind(this);
  }
  receive = async ({
    amount,
    msg,
    sender
  }: {
    amount: Uint128;
    msg: Binary;
    sender: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      receive: {
        amount,
        msg,
        sender
      }
    }, fee, memo, _funds);
  };
  deposit = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      deposit: {}
    }, fee, memo, _funds);
  };
  unbond = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unbond: {}
    }, fee, memo, _funds);
  };
  withdraw = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw: {}
    }, fee, memo, _funds);
  };
  withdrawCollateral = async ({
    collections
  }: {
    collections: CollectionInfoForString[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw_collateral: {
        collections
      }
    }, fee, memo, _funds);
  };
  depositCollateral = async ({
    collections
  }: {
    collections: CollectionInfoForString[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      deposit_collateral: {
        collections
      }
    }, fee, memo, _funds);
  };
  borrow = async ({
    amount
  }: {
    amount: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      borrow: {
        amount
      }
    }, fee, memo, _funds);
  };
  repay = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      repay: {}
    }, fee, memo, _funds);
  };
  placeBid = async ({
    collections,
    discount
  }: {
    collections: CollectionInfoForString[];
    discount: Decimal;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      place_bid: {
        collections,
        discount
      }
    }, fee, memo, _funds);
  };
  updateBid = async ({
    amount,
    collections,
    creationDate,
    discount
  }: {
    amount: Uint128;
    collections: CollectionInfoForString[];
    creationDate: number;
    discount: Decimal;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_bid: {
        amount,
        collections,
        creation_date: creationDate,
        discount
      }
    }, fee, memo, _funds);
  };
  removeBid = async ({
    collectionAddresses,
    creationDate
  }: {
    collectionAddresses: string[];
    creationDate: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_bid: {
        collection_addresses: collectionAddresses,
        creation_date: creationDate
      }
    }, fee, memo, _funds);
  };
  liquidate = async ({
    targets
  }: {
    targets: LiquidationItem[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      liquidate: {
        targets
      }
    }, fee, memo, _funds);
  };
  acceptAdminRole = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      accept_admin_role: {}
    }, fee, memo, _funds);
  };
  updateAddressConfig = async ({
    admin,
    marketMaker,
    minter,
    oracle,
    scheduler,
    worker
  }: {
    admin?: string;
    marketMaker?: string;
    minter?: string;
    oracle?: string;
    scheduler?: string;
    worker?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_address_config: {
        admin,
        market_maker: marketMaker,
        minter,
        oracle,
        scheduler,
        worker
      }
    }, fee, memo, _funds);
  };
  updateRateConfig = async ({
    bidMinRate,
    borrowApr,
    borrowFeeRate,
    discountMaxRate,
    discountMinRate,
    liquidationFeeRate
  }: {
    bidMinRate?: Decimal;
    borrowApr?: Decimal;
    borrowFeeRate?: Decimal;
    discountMaxRate?: Decimal;
    discountMinRate?: Decimal;
    liquidationFeeRate?: Decimal;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_rate_config: {
        bid_min_rate: bidMinRate,
        borrow_apr: borrowApr,
        borrow_fee_rate: borrowFeeRate,
        discount_max_rate: discountMaxRate,
        discount_min_rate: discountMinRate,
        liquidation_fee_rate: liquidationFeeRate
      }
    }, fee, memo, _funds);
  };
  updateCommonConfig = async ({
    bglCurrency,
    borrowersReserveFractionRatio,
    collateralMinValue,
    mainCurrency,
    unbondingPeriod
  }: {
    bglCurrency?: CurrencyForTokenUnverified;
    borrowersReserveFractionRatio?: Decimal;
    collateralMinValue?: Uint128;
    mainCurrency?: CurrencyForTokenUnverified;
    unbondingPeriod?: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_common_config: {
        bgl_currency: bglCurrency,
        borrowers_reserve_fraction_ratio: borrowersReserveFractionRatio,
        collateral_min_value: collateralMinValue,
        main_currency: mainCurrency,
        unbonding_period: unbondingPeriod
      }
    }, fee, memo, _funds);
  };
  depositReserveLiquidity = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      deposit_reserve_liquidity: {}
    }, fee, memo, _funds);
  };
  withdrawReserveLiquidity = async ({
    amount
  }: {
    amount: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw_reserve_liquidity: {
        amount
      }
    }, fee, memo, _funds);
  };
  reinforceBglToken = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      reinforce_bgl_token: {}
    }, fee, memo, _funds);
  };
  pause = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      pause: {}
    }, fee, memo, _funds);
  };
  unpause = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unpause: {}
    }, fee, memo, _funds);
  };
  distributeFunds = async ({
    addressAndWeightList
  }: {
    addressAndWeightList: string[][];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      distribute_funds: {
        address_and_weight_list: addressAndWeightList
      }
    }, fee, memo, _funds);
  };
  removeCollection = async ({
    address
  }: {
    address: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_collection: {
        address
      }
    }, fee, memo, _funds);
  };
  createProposal = async ({
    proposal
  }: {
    proposal: ProposalForStringAndTokenUnverified;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      create_proposal: {
        proposal
      }
    }, fee, memo, _funds);
  };
  rejectProposal = async ({
    id
  }: {
    id: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      reject_proposal: {
        id
      }
    }, fee, memo, _funds);
  };
  acceptProposal = async ({
    id
  }: {
    id: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      accept_proposal: {
        id
      }
    }, fee, memo, _funds);
  };
}